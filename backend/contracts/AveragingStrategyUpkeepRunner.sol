// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

// AutomationCompatible.sol imports the functions from both ./AutomationBase.sol and
// ./interfaces/AutomationCompatibleInterface.sol
import "@chainlink/contracts/src/v0.8/AutomationCompatible.sol";

import "./AveragingStrategy.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract AveragingStrategyUpkeepRunner is AutomationCompatibleInterface {

    // Chainlink automation functions
    function checkUpkeep(bytes calldata checkData) external view override
        returns (bool upkeepNeeded, bytes memory performData)
    {
        // Gets the AveragingStrategy.AveragingStrategyConfig[] on checkData
        AveragingStrategy.AveragingStrategyConfig[] memory averagingStrategies = abi.decode(checkData, (AveragingStrategy.AveragingStrategyConfig[]));

        // First gets number of elements requiring updates
        uint256 counter;
        for (uint i = 0; i < averagingStrategies.length; i++) {
            if (block.timestamp - averagingStrategies[i].creationTimestamp > averagingStrategies[i].frequency) {
                counter++;
            }
        }

        // Initializes array of elements requiring to average buy
        AveragingStrategy.AveragingStrategyConfig[] memory averagingStrategiesToUpdate = new AveragingStrategy.AveragingStrategyConfig[](counter);

        upkeepNeeded = false;
        uint256 indexCounter;

        // For each averaging strategy...
        for (uint i = 0; i < averagingStrategies.length; i++) {
            // ...if more time has passed than the defined frequency...
            if (block.timestamp - averagingStrategies[i].creationTimestamp > averagingStrategies[i].frequency) {
                upkeepNeeded = true;

                // ...store it in strategies to update
                averagingStrategiesToUpdate[indexCounter] = averagingStrategies[i];
                indexCounter++;
            }
        }
        performData = abi.encode(averagingStrategiesToUpdate);
        return (upkeepNeeded, performData);
    }

// emit AveragingStrategy.AveragingStrategyConfigUpdated(
//     averagingAddresses[i],
//     averagingStrategy.sourceToken,
//     averagingStrategy.averagedToken,
//     averagingStrategy.isActive,
//     averagingStrategy.amount,
//     averagingStrategy.frequency,
//     averagingStrategy.averagingStrategyId
// );

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        // if ((block.timestamp - lastTimeStamp) > interval) {
        //     lastTimeStamp = block.timestamp;
        //     counter = counter + 1;
        // }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }
}
